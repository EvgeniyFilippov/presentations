= Java Memory Management

== Intro

=== Размер объекта

JVM хранит для каждого объекта:

* Заголовок объекта;
** 8 байт (32-х разрядная ОС)
** 16 байт (64-х разрядная ОС)
* Память для примитивных типов;
* Память для ссылочных типов;
* Смещение/выравнивание

=== Размер объекта

[source,java]
[.fragment]
----
//примитив
int i = 25;    // размер примитива
//объект
Integer b = 25; //размер(reference) + размер примитива (int)
----

=== Размер объекта

* *Заголовок*: 16 байт
* *Поле* `int`: 4 байта
* *Выравнивание для кратности 8*: 4 байта
* *Итого*: 24 байта

== GC

=== GC

* Объекты создаются динамически с помощью операции new, а уничтожаются автоматически.
* Когда никаких ссылок на объект не существует (все ссылки на него вышли из области видимости программы) предполагается, что объект больше не нужен, и память, занятая объектом, может быть освобождена.
* “Сборка мусора” происходит нерегулярно во время выполнения программы. Рекомендовано ее выполнить вызовом метода System.gc() или Runtime.getRuntime().gc().
* Вызов метода System.runFinalization() приведет к запуску метода finalize()  для объектов утративших все ссылки.

=== GC

* В Java пересмотрена концепция динамического распределения памяти: отсутствуют способы освобождения динамически выделенной памяти. Вместо этого реализована система автоматического освобождения памяти (сборщик мусора), выделенной с помощью оператора new.
* Сборщик мусора уничтожает объекты, которым не соответствует ни одна ссылка из активного потока.
* Аналогом деструктора можно считать метод finalize(), который исполняющая среда языка Java будет вызывать каждый раз, когда сборщик мусора будет уничтожать объекты этого класса.
* Сборщиком мусора — специальный процесс периодически освобождает память, удаляя объекты, которые уже не будут востребованы приложениями — то есть производит «сбор мусора».





