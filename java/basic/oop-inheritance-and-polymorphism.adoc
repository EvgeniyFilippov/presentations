= Inheritance and Polymorphism

== Problem

=== Problem

Возникает необходимость создания классов, которые отличаются несколькими полями/методами.

== Inheritance

=== Inheritance

image::/assets/img/java/basic/oop/inheritance-and-polymorphism/inheritance-1.svg[OOP: inheritance]

=== Inheritance

image::/assets/img/java/basic/oop/inheritance-and-polymorphism/inheritance-2.svg[OOP: inheritance]

=== Inheritance

image::/assets/img/java/basic/oop/inheritance-and-polymorphism/inheritance-3.svg[OOP: inheritance]

=== Inheritance

image::/assets/img/java/basic/oop/inheritance-and-polymorphism/inheritance-4.svg[OOP: inheritance]

=== Inheritance

image::/assets/img/java/basic/oop/inheritance-and-polymorphism/inheritance-5.svg[OOP: inheritance]

=== Inheritance

image::/assets/img/java/basic/oop/inheritance-and-polymorphism/inheritance-6.svg[OOP: inheritance]

=== Inheritance

[.step]
* Повторное использование кода
* Расширение родительского класса
* Дочерний класс будет уметь всё, что умел родительский плюс добавляет что-то своё

=== Inheritance

image::/assets/img/java/basic/oop/inheritance-and-polymorphism/inheritance-7.svg[OOP: inheritance]

=== Subclass

Дочерний класс видит:

[.step]
* Открытые методы и переменные с модификатором `public`
* Защищённые (`protected`) методы и переменные
* Методы и переменные на уровне пакета (без модификатора доступа), если суперкласс в том же пакете, что и дочерний – так делать нежелательно


=== Inheritance

[.step]
* Все объекты наследуются от `Object`, даже если не указан `extends Object`
* Родительские классы не наследуют элементы дочернего класса!
* В дочерних классах при наследовании можно расширять модификатор доступа, но нельзя сужать
* В Java нет множественного наследования, как в C++

=== Inheritance

[.step]
* Когда есть общее поведение для каких-либо объектов – нужно выносить его в родительский класс.
* Нужно уметь правильно наследоваться, т.е. выделять общие классы.
* Наследование избавляет вашу программу от избыточности.

=== Inheritance

[.step]
* Если нужно изменить общее поведение, то наследование автоматически передаст это изменение для всех дочерних классов.
* Дочерний класс наследует доступные методы и переменные от родительского класса и может прибавлять свои собственные методы и переменные.

== Inheritance vs Composition

=== Inheritance vs Composition

[.step]
* Наследование – не всегда лучший инструмент для повторного использования кода из-за привязки к архитектуре наследования.
* Старайтесь использовать композицию вместо наследования.
* По времени жизни внутренние объекты зависят от объекта, в котором они созданы.

=== Inheritance vs Composition

[.step]
* Если объекты связаны по типу «содержит», то нужно применять композицию
* Если объекты связаны по типу «является», то нужно применять наследование

== `final`

=== `final`

[.step]
* Переменная, объявленная `final` не может изменить своё значение.
* Метод, объявленный `final` не может быть переопределён в подклассе.
* Класс, объявленный `final` не может иметь подклассы.

=== `final`

[.step]
* Однако, у объектной переменной можно изменить внутреннее состояние (свойства) с помощью вызова методов, даже если она объявлена `final`.
* Объявление `private`-методов `final` не имеет смысла, так как `private`-методы не наследуются

== Polymorphism

=== Polymorphism

[.step]
* Один интерфейс – множество реализаций
* Одно имя – множество вариантов выполнения

=== Polymorphism

image::/assets/img/java/basic/oop/inheritance-and-polymorphism/inheritance-8.svg[OOP: inheritance]

== Abstract classes and Interfaces

=== Abstract classes and Interfaces

image::/assets/img/java/basic/oop/inheritance-and-polymorphism/inheritance-9.svg[OOP: inheritance]

=== Abstract classes

[.step]
* Абстрактный класс нужен для того, чтобы задать модель поведения для всех дочерних объектов.
* Нельзя создать экземпляр абстрактного класса (через `new`), потому что он ничего не умеет, это просто шаблон поведения для дочерних классов.

=== Abstract classes

[.step]
* Если класс имеет хотя бы один абстрактный метод то он будет абстрактным
* Любой дочерний класс должен реализовать все абстрактные методы родительского, либо он сам должен быть абстрактным
* Абстрактный класс может быть абстрактным и при этом не иметь ни одного абстрактного метода

=== Interfaces

[.step]
* Интерфейс – более «строгий» вариант абстрактного класса. Методы могут быть только абстрактными.
* Интерфейс задаёт только поведение, без реализации.
* Интерфейс может наследоваться от одного или нескольких интерфейсов.

=== Abstract classes vs Interfaces

[.step]
* Интерфейс может наследоваться от множества интерфейсов, абстрактный класс - только от одного класса.
* Совет: если есть возможность – используйте интерфейсы.

=== Abstract classes vs Interfaces

[.step]
* Интерфейс может наследоваться от множества интерфейсов, абстрактный класс - только от одного класса.
* Совет: если есть возможность – используйте интерфейсы.
